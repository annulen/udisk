#!/usr/bin/env perl

use List::Util qw/max/;

use strict;
use warnings;

my @commands_ordered;
my %commands;

main();

sub help {
    print "Usage: $0 [COMMAND]\n\n";
    print "Commands:\n";
    for(my $i = 0; $i < @commands_ordered; $i += 2) {
        my ($name, $value) = @commands_ordered[$i, $i + 1];
        printf "  %-15s  %s\n", $name, $value->[1];
    }
}

sub usage {
    print "@_\n";
    help();
    exit(1);
}

sub status_processHeader {
    my $pipe = shift;

    # MODEL REVISION SERIAL DEVICE
    # ----------------------------
    my $hdr = <$pipe>;
    $hdr =~ /^MODEL\s+(REVISION)\s+(SERIAL)\s+(DEVICE)/ or return "";

    # Get widths of first three columns in header line, leaving one character
    # for spacing
    my ($i, $j, $k) = map { $-[$_] - $-[$_-1] - 1 } 1..3;

    # 1. Fields have minimum width of at least $i, $j, $k, but maximum width
    #    is not limited
    # 2. Fields are always separated by at least one space
    my $in_fmt = qr/^(.{$i,}?)\s+(.{$j,}?)\s+(.{$k,}?)\s+(\S+)/;

    my $model_width = max(32, $i);
    my $out_fmt = "%-${model_width}s %s";

    $_ = <$pipe>;
    /^-*$/ or return "";
    return $in_fmt, $out_fmt;
}

sub status_printDev {
    my ($model, $dev, $paths, $out_fmt) = @_;
    my $mount_point = defined $paths ? $paths->{$dev} // "Not mounted"
                                     : "";
    printf $out_fmt, $model, "$dev\t\t$mount_point\n";
}

sub status_printDevRoot {
    my ($model, $dev, $paths, $out_fmt) = @_;

    $dev = "/dev/$dev";
    -e "$dev" or die "Device file does not exist: $dev";
    my @devs = glob("$dev*");

    status_printDev $model, $devs[0], undef, $out_fmt;
    for my $i (1..$#devs) {
        status_printDev '', $devs[$i], $paths, $out_fmt;
    }
}

sub loadMountPoints {
    my %paths;
    open my $mounts, '<', '/proc/mounts';
    while (<$mounts>) {
        my ($dev, $path) = split ' ', $_, 3;
        # For now we save only one mount point path per device
        $paths{$dev} = $path;
    }
    return \%paths;
}

sub status {
    my $cmd = "udisksctl status";
    open my $pipe, "-|", $cmd or die "$cmd failed: $!";

    my ($in_fmt, $out_fmt) = status_processHeader($pipe, $cmd)
        or usage "Unrecognized output format for `$cmd'";

    my $paths = loadMountPoints();

    while (<$pipe>) {
        my @fields = m/$in_fmt/;
        @fields == 4 or die "Failed to parse line: $_";
        my $dev = pop @fields;
        status_printDevRoot($fields[0], $dev, $paths, $out_fmt);
    }
}

sub mount {
    my $cmd = "udisksctl mount -b";
    for my $dev (@_) {
        print "$cmd $dev\n";
        system("$cmd $dev");
        print "Exit code: $?\n";
        print "\n";
    }
}

sub umount {
    my $cmd = "udisksctl unmount -b";
    for my $dev (@_) {
        print "$cmd $dev\n";
        system("$cmd $dev");
        print "Exit code: $?\n";
        print "\n";
    }
}

sub wait {
    my $cmd = "udisksctl monitor";
    my $pid = open my $pipe, "-|", $cmd or die "$cmd failed: $!";
    while (<$pipe>) {
        print;
        last if (/^[0-9.:]+: Added /);
    }
    print "Stopping monitor...\n";
    kill 9, $pid;
    print "\n";
    status();
}

sub command {
    my ($name, $data) = @_;
    push @commands_ordered, $name => $data;
    $commands{$name} = $data;
}

sub main {
    command 'status' => [ \&status, "Prints high-level status (default command)" ];
    command 'mount'  => [ \&mount, "Mounts a filesystem" ];
    command 'umount' => [ \&umount, "Unmounts a filesystem" ];
    command 'wait'   => [ \&wait, "Waits for new device to appear then prints status" ];
    command 'help'   => [ \&help, "Shows this information" ];

    my $cmd = shift @ARGV // "status";
    exists $commands{$cmd} or usage "Unknown command `$cmd'";
    $commands{$cmd}->[0]->(@ARGV);
}

