#!/usr/bin/env perl

use strict;
use warnings;

my @commands_ordered = (
    status => "Shows high-level status",
    mount => "Mount a filesystem",
    umount => "Unmount a filesystem",
    help => "Shows this information"
);
my %commands = @commands_ordered;

sub help {
    print "Usage: $0 COMMAND\n\n";
    print "Commands:\n";
    for(my $i = 0; $i < @commands_ordered; $i += 2) {
        my ($c, $h) = @commands_ordered[$i, $i + 1];
        printf "  %-15s  %s\n", $c, $h;
    }
}

sub usage {
    print "@_\n";
    help();
    exit(1);
}

sub status_processHeader {
    my $pipe = shift;

    # MODEL REVISION SERIAL DEVICE
    # ----------------------------
    my $hdr = <$pipe>;
    $hdr =~ /^MODEL\s+(REVISION)\s+(SERIAL)\s+(DEVICE)/ or return "";

    my @l = map { $-[$_] - $-[$_-1] } 1..3;
    my $in_fmt = sprintf "A%sA%sA%sA*", @l;
    my $out_fmt = sprintf "A%sA*", $l[0];

    $_ = <$pipe>;
    /^-*$/ or return "";
    return $in_fmt, $out_fmt
}

sub status {
    my $cmd = "udisksctl status";
    open my $pipe, "-|", $cmd;

    my ($in_fmt, $out_fmt) = status_processHeader($pipe, $cmd)
        or usage "Unrecognized output format for `$cmd'";

    while (<$pipe>) {
        my @fields = unpack $in_fmt;
        my $dev = pop @fields;
        my @devs = glob("/dev/$dev*");
        print pack $out_fmt, $fields[0], "@devs\n";
    }
}

sub mount {
    my $cmd = "udisksctl mount -b";
    for my $dev (@_) {
        print "$cmd $dev\n";
        system("$cmd $dev");
        print "\n";
    }
}

sub umount {
    my $cmd = "udisksctl unmount -b";
    for my $dev (@_) {
        print "$cmd $dev\n";
        system("$cmd $dev");
        print "\n";
    }
}

my $cmd = shift @ARGV;
exists $commands{$cmd} or usage "Unknown command `$cmd'";
{
    no strict 'refs';
    &$cmd(@ARGV);
}
